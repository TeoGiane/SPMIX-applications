install.packages("devtools")
q()
devtools::install_github("TeoGiane/SPMIX")
library(SPMIX)
detach("package:SPMIX", unload = TRUE)
setwd("~/Documents/SPMIX_CensusData")
library("ggplot2")
library("ggmap")
library("sf")
library("sp")
library("dplyr")
library("SPMIX")
# Import SpatialPolygonsDataFram and proper setting
spdf_usa <- as_Spatial(read_sf("us-pumas_boundaries/ipums_puma_2010.shp"))
spdf_usa <- spTransform(spdf_usa, CRS("+proj=longlat +datum=WGS84"))
install.packages("rgdal")
# Setting MCMC parameters
burnin = 100
niter = 100
thin = 1
# Grab input filenames
params_filename = system.file("input_files/rjsampler_params.asciipb", package = "SPMIX")
# Run Spatial sampler
out <- Sampler.BoundaryDetection(burnin, niter, thin, data, W, params_filename)
library("ggplot2")
library("ggmap")
library("sf")
library("sp")
library("dplyr")
library("SPMIX")
spdf_usa <- as_Spatial(read_sf("us-pumas_boundaries/ipums_puma_2010.shp"))
spdf_usa <- spTransform(spdf_usa, CRS("+proj=longlat +datum=WGS84"))
spdf_usa$id <- row.names(spdf_usa)
spdf_usa$PUMA <- as.character(as.numeric(spdf_usa$PUMA))
# Extract California PUMAs
spdf_cali <- spdf_usa[which(spdf_usa$State == "California"), ]
# LA + Ventura + Orange County
sel_county <- c("Los Angeles County", "Ventura County", "Orange County")
spdf <- spdf_cali[grep(paste(sel_county, collapse = "|"), spdf_cali$Name), ]
# Import raw data
rdata <- read.csv("csv_pca/psam_p06.csv")
rdata <- rdata[which(rdata$PINCP > 0),]
rdata$PUMA <- as.character(rdata$PUMA)
# Extract data for SPMIX
pumas <- spdf@data$PUMA
data <- list()
for (i in 1:length(pumas)) {
set.seed(230196)
tmp <- rdata$PINCP[which(rdata$PUMA == pumas[i])]
data[[i]] <- log(tmp[sample(1:length(tmp), 100)])
}
# Compute adjacency matrix
adj_list <- spdep::poly2nb(spdf, row.names = pumas, queen = FALSE)
W <- as.matrix(igraph::as_adj(igraph::graph_from_adj_list(adj_list, mode = "all")))
# Setting MCMC parameters
burnin = 100
niter = 100
thin = 1
# Grab input filenames
params_filename = system.file("input_files/rjsampler_params.asciipb", package = "SPMIX")
# Run Spatial sampler
out <- Sampler.BoundaryDetection(burnin, niter, thin, data, W, params_filename)
View(Sampler.BoundaryDetection)
View(:parseData)
View(SPMIX:::parseData)
parseData <- function (data)
{
if (typeof(data) == "character") {
cat("Data are provided as a path to a csv file\n")
data_in <- ReadDataFromCSV(data)
if (all(is.na(data_in)))
stop("Input file for 'data' does not exist.")
}
else if (typeof(data) == "list" && sapply(data, function(x) return(typeof(x) ==
"double" && length(x) > 0))) {
cat("Data are provided as a list of numeric vectors\n")
data_in <- data
}
else {
stop("Input parameter 'data' is of unknown type.")
}
return(data_in)
}
tmp <- parseData(data)
parseData <- function (data)
{
if (typeof(data) == "character") {
cat("Data are provided as a path to a csv file\n")
data_in <- ReadDataFromCSV(data)
if (all(is.na(data_in)))
stop("Input file for 'data' does not exist.")
}
else if (typeof(data) == "list" && sapply(data, function(x) return(typeof(x) ==
"double" & length(x) > 0))) {
cat("Data are provided as a list of numeric vectors\n")
data_in <- data
}
else {
stop("Input parameter 'data' is of unknown type.")
}
return(data_in)
}
tmp <- parseData(data)
sapply(data, function(x) return(typeof(x) ==
"double" && length(x) > 0))
typeof(data) == "list" && sapply(data, function(x) return(typeof(x) ==
"double" && length(x) > 0))
typeof(data) == "list" && prod(sapply(data, function(x) return(typeof(x) ==
"double" && length(x) > 0)))
devtools::install_github("TeoGiane/SPMIX")
install.packages(c("cli", "highr", "purrr", "xfun"))
install.packages(c("cli", "highr", "purrr", "xfun"))
install.packages(c("cli", "highr", "purrr", "xfun"))
setwd("~/")
rm(list=ls())
install.packages(c("cli", "highr", "purrr", "xfun"))
install.packages(c("cli", "highr", "purrr", "xfun"))
install.packages("IRkernel")
IRkernel::installspec()
IRkernel::installspec()
View(IRkernel::installspec)
IRkernel::installspec()
jupyter-client has to be installed but “jupyter kernelspec --version” exited with code 127
exit_code <- system2("jupyter", c("kernelspec", "--version"),
FALSE, FALSE)
?system2
exit_code <- system2("jupyter", c("kernelspec", "--version"))
exit_code <- system2("jupyter", c("kernelspec", "--version"))
q()
q()
remove.packages("SPMIX", lib="~/R/x86_64-pc-linux-gnu-library/4.2")
devtools::install_github("TeoGiane/SPMIX")
setwd("~/Documents/GitHub/SPMIX-applications/SimulationStudies")
# Required libraries
library("SPMIX")
library("ggplot2")
# Generate data (1 location, mixture of 3 normals)
set.seed(230196)
ngroups <- 1; ncomponents <- 4; N <- 1000
means <- c(-4,1,5,8); std_devs <- c(1,1,1,1); weights <- matrix(c(2/8,3/8,1/8,2/8),ngroups,ncomponents,T)
cluster_alloc <- sample(1:ncomponents, prob = weights, size = N, replace = T)
data <- list(); data[[1]] <- rnorm(N, mean = means[cluster_alloc], sd = std_devs[cluster_alloc])
# Generate Matrix W
W <- matrix(0, nrow = 1, ncol = 1, byrow = T)
# Setting MCMC parameters
burnin = 5000
niter = 5000
thin = 2
# Grab input filenames
params_filename = system.file("input_files/rjsampler_params.asciipb", package = "SPMIX")
# Run Spatial sampler
out <- Sampler.DensityEstimation(burnin, niter, thin, data, W, params_filename, type="rjmcmc")
# Deserialization
chains <- sapply(out, function(x) DeserializeSPMIXProto("UnivariateState",x))
H_chain <- sapply(chains, function(x) x$num_components)
# Barplot of the estimated posterior for H
df <- as.data.frame(table(H_chain)/length(H_chain)); names(df) <- c("NumComponents", "Prob.")
plot_postH <- ggplot(data = df, aes(x=NumComponents, y=Prob.)) +
geom_bar(stat="identity", color="steelblue", fill="lightblue") +
theme(plot.title = element_text(face="bold", hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
xlab("N° of Components") #+ ggtitle("Posterior of H")
rm(list='df')
x11(height = 4, width = 4); plot_postH
# Plotting the average density over iterations and compare with true curve
# Compute estimated density
data_ranges <- sapply(data, range); Npoints <- 500
estimated_densities <- ComputeDensities(chains, Npoints, data_ranges, alpha = 0.05)
# Compute true densities
true_densities <- list()
for (i in 1:ngroups) {
x_grid <- seq(data_ranges[1,i], data_ranges[2,i], length.out = Npoints)
xgrid_expand <- t(rbind(replicate(ncomponents, x_grid, simplify = "matrix")))
true_dens <- t(as.matrix(weights[i,])) %*% dnorm(xgrid_expand, means, std_devs)
true_densities[[i]] <- true_dens
}
# Density comparison - Plot
# Auxiliary dataframe
df <- data.frame('grid'=seq(data_ranges[1,1], data_ranges[2,1], length.out=Npoints),
t(estimated_densities[[1]]),
'true'=t(true_densities[[1]]))
# Generate plot
plot_densCompare <- ggplot(data = df, aes(x=grid)) +
geom_line(aes(y=est, color="Estimated"), linewidth = 1) +
geom_line(aes(y=true, color="True"), linewidth = 1) +
scale_color_manual("", breaks=c("Estimated","True"), values=c("Estimated"="darkorange", "True"="steelblue")) +
theme(plot.title = element_text(face="bold", hjust = 0.5)) +
theme(legend.title=element_blank(), legend.position="bottom") +
xlab("Grid") + ylab("Density") + ggtitle(paste0("Area ", i))
# Add credibility band if present
if (dim(estimated_densities[[i]])[1] > 1) {
plot_densCompare <- plot_densCompare + geom_ribbon(aes(ymax=up, ymin=low), fill="orange", alpha=0.3)
}
# Clean useless variables
rm(list='df')
x11(width = 6, height = 4); plot_densCompare
